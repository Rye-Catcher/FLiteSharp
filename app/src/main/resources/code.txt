//Test basic operations
1 + 1
1 - 1
1 * 2
1 / 2
2 ** 10
1 - -1
1 >= 2
1 < 2
true && false
true || false

//Test bindings
let x : int = 1
let y : int = 2

//Test lambda expressions
fun (x : double) (y : double) -> x + y
fun () -> 1

//Test function declarations
let foo (x : int) : int = {
    x + 1
}
let bar () : int  = {
    let x : int = -19260817
    x
}

//Test function applications
foo(1)
foo(x + 1)

//Test passing lambda expr as arguments
let lam (f : int -> int) : int = {
    f(1)
}

lam(fun (x : int) -> x + 1)

//Test application with no arguments
bar()

//Test nested functions
let nest (x : int) : int = {
    let foo (x : int) : int = {
        let bar (x : int) : int = {
            x + 1
        }
        bar(x + 1)
    }
    foo(x + 1)
}

nest(x)

if  if 3 > 2
    then {true}
    else {false}
then {4}
else {5}

if true then {
    let a : int = 4
    let b : int = 5
    a + b
}

1 :: [2; 3; 2 + 2]
[1; 2] @ [3; 2 + 2]

let a : int = 0
for i = 1 to 10 do {
    i + 1
}

for i = 10 downto 1 do {
    i + 1
}

for i in 3..(5+2) do {
    i+1
}

for i in 1..2..11 do {
    i+1
}

for i in [2; 4; 6] do {
    i+1
}

let d : (int -> int) list = [(fun (x:int) -> x); (fun (x:int) -> x*2)]

let f (g : int -> int -> int)(x : int)(y : int) : int = {g x y + 1}

let g : (int -> int -> int) = fun (x : int)(y : int) -> x*y

let h (f:(int -> int -> int) -> int -> int -> int) : int = {f g 10 20}

(*
Test multiple line comment
*)