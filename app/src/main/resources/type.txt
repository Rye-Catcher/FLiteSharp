1 + 1;
1 - 1;
1 * 2;
1 / 2;
2.0 ** 10.0;
1 - -1;
1 >= 2;
1 < 2;
true && false;
true || false;
( );

let x : int = 1 in
x;

fun (x : unit) (t : int) -> 1;

// Test Lambda function as argument
let foo (f : int -> int) : int = begin
    f 1;
end in

foo (fun (x : int) -> x + 1);

// Test nested functions
let nest (x : int) : int = begin
    let foo (x : int) : int = begin
        let bar (x : int) : int = begin
            x + 1;
        end in
        bar x + 1;
    end in
    foo x + 1;
end in

nest x;

if begin if 3 > 2
         then begin true; end
         else begin false; end;
   end
then begin 4; end
else begin 5; end;

1 :: [2; 3; 2 + 2];
[1; 2] @ [3; 2 + 2];

let f (g : int -> int -> int)(x : int)(y : int) : int =  begin (g x y) + 1; end in

let g : (int -> int -> int) = (fun (x : int)(y : int) -> x * y) in

let h (f:(int -> int -> int) -> int -> int -> int) : int = begin f g 10 20; end in

[];

(1, true, ());

let tf (x : (int * bool * unit)) : (int * bool * unit) = begin x; end in

tf (1, true, ());

let rec fact (x : int):int = begin
    if x = 0
    then begin
        1;
    end
    else begin
        x * fact (x - 1);
    end;
end in

fact 6;

1 / 3 * 3 / 1;

[<Measure>] type m
[<Measure>] type s
[<Measure>] type kg

[<Measure>] type N = kg m / s^2

let g : double<m/s^2> = 9.81<m/s^2> in
let mass : double<kg> = 2.0<kg> in

let weight : double<N> = mass * g in

weight;

let ff () : int = begin 3; end in

ff ();

let gg : (unit -> int) = fun () -> begin 3; end in

gg ();